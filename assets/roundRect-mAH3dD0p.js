(()=>{Path2D.prototype.roundRect??=M,globalThis.CanvasRenderingContext2D&&(globalThis.CanvasRenderingContext2D.prototype.roundRect??=M),globalThis.OffscreenCanvasRenderingContext2D&&(globalThis.OffscreenCanvasRenderingContext2D.prototype.roundRect??=M);function M(e,s,a,u,o){if(![e,s,a,u].every(n=>Number.isFinite(n)))return;o=N(o);let t,r,i,h;if(o.length===4)t=l(o[0]),r=l(o[1]),i=l(o[2]),h=l(o[3]);else if(o.length===3)t=l(o[0]),r=l(o[1]),h=l(o[1]),i=l(o[2]);else if(o.length===2)t=l(o[0]),i=l(o[0]),r=l(o[1]),h=l(o[1]);else if(o.length===1)t=l(o[0]),r=l(o[0]),i=l(o[0]),h=l(o[0]);else throw new RangeError(`${b(this)} ${o.length} is not a valid size for radii sequence.`);const P=[t,r,i,h],x=P.find(({x:n,y:f})=>n<0||f<0);if(x?.x<0?x.x:x?.y,P.some(({x:n,y:f})=>!Number.isFinite(n)||!Number.isFinite(f)))return;if(x)throw new RangeError(`${b(this)} Radius value ${x} is negative.`);D(P),a<0&&u<0?(this.moveTo(e-t.x,s),this.ellipse(e+a+r.x,s-r.y,r.x,r.y,0,-Math.PI*1.5,-Math.PI),this.ellipse(e+a+i.x,s+u+i.y,i.x,i.y,0,-Math.PI,-Math.PI/2),this.ellipse(e-h.x,s+u+h.y,h.x,h.y,0,-Math.PI/2,0),this.ellipse(e-t.x,s-t.y,t.x,t.y,0,0,-Math.PI/2)):a<0?(this.moveTo(e-t.x,s),this.ellipse(e+a+r.x,s+r.y,r.x,r.y,0,-Math.PI/2,-Math.PI,1),this.ellipse(e+a+i.x,s+u-i.y,i.x,i.y,0,-Math.PI,-Math.PI*1.5,1),this.ellipse(e-h.x,s+u-h.y,h.x,h.y,0,Math.PI/2,0,1),this.ellipse(e-t.x,s+t.y,t.x,t.y,0,0,-Math.PI/2,1)):u<0?(this.moveTo(e+t.x,s),this.ellipse(e+a-r.x,s-r.y,r.x,r.y,0,Math.PI/2,0,1),this.ellipse(e+a-i.x,s+u+i.y,i.x,i.y,0,0,-Math.PI/2,1),this.ellipse(e+h.x,s+u+h.y,h.x,h.y,0,-Math.PI/2,-Math.PI,1),this.ellipse(e+t.x,s-t.y,t.x,t.y,0,-Math.PI,-Math.PI*1.5,1)):(this.moveTo(e+t.x,s),this.ellipse(e+a-r.x,s+r.y,r.x,r.y,0,-Math.PI/2,0),this.ellipse(e+a-i.x,s+u-i.y,i.x,i.y,0,0,Math.PI/2),this.ellipse(e+h.x,s+u-h.y,h.x,h.y,0,Math.PI/2,Math.PI),this.ellipse(e+t.x,s+t.y,t.x,t.y,0,Math.PI,Math.PI*1.5)),this.closePath(),this.moveTo(e,s);function R(n){const{x:f,y:c,z:p,w:y}=n;return{x:f,y:c,z:p,w:y}}function N(n){const f=typeof n;return f==="undefined"||n===null?[0]:f==="function"?[NaN]:f==="object"?typeof n[Symbol.iterator]=="function"?[...n].map(c=>{const p=typeof c;return p==="undefined"||c===null?0:p==="function"?NaN:p==="object"?R(c):g(c)}):[R(n)]:[g(n)]}function g(n){return+n}function l(n){const f=g(n);return Number.isFinite(f)?{x:f,y:f}:Object(n)===n?{x:g(n.x??0),y:g(n.y??0)}:{x:NaN,y:NaN}}function D(n){const[f,c,p,y]=n,T=[Math.abs(a)/(f.x+c.x),Math.abs(u)/(c.y+p.y),Math.abs(a)/(p.x+y.x),Math.abs(u)/(f.y+y.y)],I=Math.min(...T);if(I<=1)for(const C of n)C.x*=I,C.y*=I}}function b(e){return`Failed to execute 'roundRect' on '${m(e)}':`}function m(e){return Object(e)===e&&e instanceof Path2D?"Path2D":e instanceof globalThis?.CanvasRenderingContext2D?"CanvasRenderingContext2D":e instanceof globalThis?.OffscreenCanvasRenderingContext2D?"OffscreenCanvasRenderingContext2D":e?.constructor.name||e}})();
